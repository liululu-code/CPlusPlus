/*
12.1 动态内存和类
	1.对于在对象中保存字符串而言，C++通常使用new动态分配内存。通常的方法是使用string类，它为您自动处理内存管理细节。本章为了学习内存管理，使用char *指针。
	2.静态类成员
		static int num_strings;		//静态类成员
		无论程序创建了多少个对象，程序都只创建一个静态类变量副本，所有对象共享这一个副本。
		静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态成员所属的类。但如果静态类成员是整形或枚举型const，则可以在类声明中初始化。
	3.在构造函数中使用new来分配内存，必须在析构函数中使用delete来释放内存。
	4.特殊成员函数（编译器将生成下面最后三种函数地定义--如果程序使用对象的方式要求这样做。）
		默认构造函数
		默认析构函数
		复制构造函数				//也是构造函数，使用这种构造函数构造新对象
			复制构造函数用于将一个对象复制到一个新创建地对象中，也就是说，它用于初始化过程（包括按值传递参数），而不是常规的赋值过程。
			格式：
				className(const className &);
			何时调用：
				新建一个对象，并将其初始化为同类现有对象时，复制构造函数将被调用。以下四种生命都将调用复制构造函数。
					StringBad ditto(motto);		//motto是现有对象
					StringBad ditto = motto;
					StringBad ditto = StringBad(motto);
					StringBad * pStringBad = new StringBad(motto);
				由于按值传递参数会调用复制构造函数，因此最好按引用传递，省时省空间。
			有何功能：
				如果类中包含这样的静态成员，其值将在新对象创建时发生变化，则应提供一个显式复制构造函数来处理计数问题。
				隐式复制构造函数是按值进行复制地，对于指针指向的内容只复制指针地址。如果类中包含使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据。
		赋值运算符
			格式：
				className & className::operator=(const className &);
			功能及何时使用：
				将已有对象赋值给另一个对象时，将使用重载的赋值运算符。
					StringBad knot;
					knot = headline;	//使用赋值运算符
				初始化对象时，不一定使用赋值运算符
					StringBad knot = headline;		//一定使用复制构造函数，不一定使用赋值运算符，取决于编译器
				与复制构造函数类似，赋值运算符隐式实现对各个成员的按值复制，对于指针指向的内容只复制指针地址。
			解决赋值问题：提供进行赋值运算符（进行深度复制）地定义
				由于目标对象可能引用了以前分配的数据，所以函数应使用delete[] 来释放这些数据。
				应避免将对象赋值给自身，否则给对象重新赋值前可能删除对象原有的内容。
				函数返回一个指向函数调用的引用。
					代码：
						StringBad & StringBad::operator=(const StringBad & st)
						{
							if (this == &st)	//避免将对象赋值给自身
								return *this;
							delete[] str;		//free old string
							...
							return *this;
						}
		地址运算符
			隐式地址运算符返回调用对象的地址（即this指针的值），这与我们的初衷是一样的，不详细讨论。
12.2 改进后的新String类
12.3 在构造函数中使用new时应注意的事项
	1.使用new初始化对象成员时必须特别小心。
		如果在构造函数中使用new来初始化指针，应在析构函数中使用delete
		new和delete必须相互兼容，new对应于delete，new[]对应于delete[]
		如果有多个构造函数，则必须以相同地方式使用new，要么都带中括号，要么都不带，因为只有一个析构函数，所有的构造函数都必须与它兼容
		应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象
		应当定义赋值运算符，通过深度复制将一个对象赋值给另一个对象
12.4 有关返回对象的说明
	1.返回指向const对象的引用
		返回const引用的常见原因是旨在提高效率
			代码：
				const Vector & Vector::Max(const Vector & v1, const Vector & v2) const
				{
					if (v1 > v2)
						return v1;
					else
						return v2;
				}
			说明：
				返回对象将调用构造函数，返回引用则不会。
				引用指向的对象应该在调用函数执行时存在。
				v1 和 v2 都在声明为const引用，因此返回类型必须是const，这样才匹配。
	2.返回指向非const对象的引用
		代码：
			String s1("Good stuff");
			String s2, s3;
			s3 = s2 = s1;					//(1)
			cout << s1 << "is coming";		//(2)
		说明：
			(1)这里返回类型不能是const，因为方法operator=()返回一个指向s2地引用，可以对进行修改。
			(2)返回类型必须是ostream &，不能是ostream，如果使用返回类型ostream，将要求调用ostream类地构造函数，而ostream类没有公有的复制构造函数。幸运的是，返回一个执行cout的引用不会带来任何问题，因为cout已经在调用函数的作用域内。
	3.返回对象
		如果被返回的对象是调用函数中的局部变量，应返回对象而不是引用。
	4.返回const对象
		要防止返回的对象被修改，可返回const对象
12.5 使用指向对象的指针
	1.使用常规表示法来声明指向对象的指针
		String * pStr;
	2.可以将指针初始化为指向已有的对象
		String * first = &str;
	3.可以使用new来初始化指针，这将创建一个新的对象
		String * favorite = new String("welcome");
	4.对类使用new将调用相应的构造函数来初始化新创建的对象
		String * pStr = new String;
	5.可以使用 -> 运算符通过指针访问类方法
		pStr->length();
	6.可以对对象指针应用解除引用运算符 * 来获得对象
		return *pStr;
	7.delete可与常规new配合使用，但不能与定位new运算符配合使用
		代码：
			delete pStr1;		//常规new，可以使用delete
			delete pStr2;		//定位new，不能这样做
		解决方案：
			显示的为使用定位new运算符创建的对象调用析构函数。显式调用析构函数时，必须指明要销毁的对象，对于定位new申请的内存，可以使用对应的指针
				pStr2->~String();
			同时注意显式调用析构函数时，应以与创建顺序相反的顺序进行删除。晚创建的对象可能依赖于早创建的对象，另外，对于定位new运算符，仅当创建的所有对象都被销毁后，才能释放存储这些对象的缓冲区
12.6 复习各种技术
12.7 队列模拟
*/


//本章练习题不难，但是超长。有空的话把队列模拟做一遍。
#include <iostream>
#include "chapter12.h"


void Chapter12::Run()
{
	std::cout << "test";
}